# 用正则表达进行搜索

### 使用MySQL正则表达式

`MySQL`用`WHERE`子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤`SELECT`检索出的数据。

> **仅为正则表达式的一个子集** MySQL仅支持多数正则表达式实现的一个很小的子集。

#### 基本字符匹配

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '1000' ORDER BY prod_name;
```

除关键字`LIKE`被`REGEXP`替代外，这条语句看上去非常像使用`LIKE`的语句。它告诉`MySQL`：`REGEXP`后所跟的东西作为正则表达式（与文字正文1000匹配的一个正则表达式）处理。

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '.000' ORDER BY prod_name;
```

这里使用了正则表达式`.000`。`.`是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，`1000`和`2000`都匹配且返回。

```mysql
SELECT prod_name FROM products WHERE prod_name LIKE '1000' ORDER BY prod_name;
SELECT prod_name FROM products WHERE prod_name REGEXP '1000' ORDER BY prod_name;
```

> `LIKE`与`REGEXP` 
>
> `LIKE`匹配整个列。如果被匹配的文本在列值中出现，`LIKE`将不会找到它，相应的行业不会被返回（除非使用通配符）。
>
> `REGEXP`在列值内进行匹配，如果被匹配的文本在列值中出现，`REGEXP`将会找到它，相应的行将被返回。

> **匹配不区分大小写**  `MySQL`中的正则表达式匹配不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用`BINARY`关键字，如`WHERE prod_name REGEXP BINARY 'JetPark .000'`

#### 进行OR匹配

为搜索两个串之一（或者为这个串，或者为另一个串），使用`|`。

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '1000|2000' ORDER BY prod_name;
```

语句中使用了正则表达式`1000|2000`。`|`为正则表达式的`OR`操作符。它表示匹配其中之一，因此`1000`和`2000`都匹配并返回。

使用`|`从功能上类似于在`SELECT`语句中使用`OR`语句，多个`OR`条件可并入单个正则表达式。

> **两个以上的OR条件**  可以给出两个以上的`OR`条件。例如，`'1000|2000|3000'`将匹配`1000`或`2000`或`3000`。

#### 匹配几个字符之一

匹配任何单一字符。但是，如果你只想匹配特定的字符，怎么办？可通过指定一组用`[`和`]`括起来的字符来完成。

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '[123] Ton' ORDER BY prod_name;
```

这里，使用了正则表达式`[123] Ton`。`[123]`定义一组字符，它的意思是匹配1或2或3。

正如所见，`[]`是另一种形式的`OR`语句。事实上，正则表达式`[123] Ton`为`[1|2|3] Ton`的缩写，也可以使用后者。但是，需要用`[]`来定义`OR`语句查找什么。

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '1|2|3 Ton' ORDER BY prod_name'
```

上述语句，`MySQL`会理解为`1`或`2`或`3 Ton`。除非把字符`|`括在一个集合中，否则它将应用于整个串。

字符集也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个`^`即可。因此，尽管`[123]`匹配字符`1、2`或`3`，但`[^123]`却匹配除这些字符外的任何东西。

#### 匹配范围

集合可用来定义要匹配的一个或多个字符。比如匹配`[0123456789]`，可以使用`-`来定义一个范围。`[0-9]`功能与前面的数字列表一样。

范围不限于完整的集合，`[1-3]`和`[6-9]`也是合法的范围。此外，范围不一定只是数值的，`[a-z]`匹配任意字符字符。

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '[1-5] Ton' ORDER BY prod_name;
```

#### 匹配特殊字符

正则表达式语言由具有特定含义的特殊字符构成。我们已经看到`.、[]、|`和`-`等，还有其他一些字符。如果需要匹配这些字符，应该怎么办呢？

为了匹配特殊字符，必须使用`\\`为前导。`\\-`表示查找`-`，`\\.`表示查找`.`。

```mysql
SELECT vend_name FROM vendors WHERE vend_name REGEXP '\\.' ORDER BY vend_name;
```

 这种处理就是所谓的转义，正则表达式内具有特殊意义的所有字符都必须以这种方式转义。这包括`.、|、[]`以及迄今为止使用过的其他特殊字符。

`\\`也用来引用元字符（具有特殊含义的字符）

| 元字符 |   说明   |
| :----: | :------: |
|  \\\f  |   换页   |
|  \\\n  |   换行   |
|  \\\r  |   回车   |
|  \\\t  |   制表   |
|  \\\v  | 纵向制表 |

> **匹配`\`**  为了匹配反斜杠`（\）`字符本身，需要使用`\\\`。
>
> `\`或`\\?` 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但`MySQL`要求两个反斜杠（`MySQL`自己解释一个，正则表达式库解释另外一个）。

#### 匹配字符类

存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为**字符类**。

|      类      |                        说明                         |
| :----------: | :-------------------------------------------------: |
| `[:alnum:]`  |          任意字母和数字（同`[a-zA-Z0-9]`）          |
| `[:alpha:]`  |               任意字符（同`[a-zA-Z]`)               |
| `[:blank:]`  |              空格和制表（同`[\\t]`)）               |
| `[:cntrl:]`  |          ASCII控制字符（ASCII 0到31和127）          |
| `[:digit:]`  |                任意数字（同`[0-9]`）                |
| `[:graph:]`  |            与[:print:]相同，但不包括空格            |
| `[:lower:]`  |              任意小写字母（同`[a-z]`）              |
| `[:print:]`  |                   任意可打印字符                    |
| `[:punct:]`  |    既不在`:alnum:]`又不在`[:cntrl:]`中的任意字符    |
| `[:space:]`  | 包括空格在内的任意空白字符（同`[\\f\\n\\r\\t\\v]`） |
| `[:upper:]`  |              任意大写字母（同`[A-Z]`）              |
| `[:xdigit:]` |         任意十六进制数字（同`[a-fA-F0-9]`）         |

#### 匹配多个实例

目前为止使用的所有正则表达式都试图匹配单次出现。如果存在一个匹配，改行被检索出来，如果不存在，检索不出任何行。但有时需要对匹配的数目进行更强的控制。例如，你可能需要寻找所有的数，不管数中包含多少数字，或者你可能想寻找一个单词并且还能够适应一个尾随的`s`（如果存在），等的。

这可以用正则表达式重复元字符来完成。

| 元字符  |             说明             |
| :-----: | :--------------------------: |
|   `*`   |        0个或多个匹配         |
|   `+`   | 1个或多个匹配（等于`{1,}`）  |
|   `?`   | 0个或1个匹配（等于`{0,1}`）  |
|  `{n}`  |        指定数目的匹配        |
| `{n,}`  |     不少于指定数目的匹配     |
| `{n,m}` | 匹配数目的范围（m不超过255） |

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '\\([0-9] sticks?)\\' ORDER BY prod_name;
```

正则表达式`\\(0-9) sticks?\\`需要解说一下。`\\`（匹配），`[0-9]`匹配任意数字，`stick?`匹配`stick`和`stick`后任意一个字符。

```mysql
SELECT prod_name FROM prdocuts WHERE prod_name REGEXP '[[:digit:]]{4}' ORDER BY prod_name;
```

`[:digit:]`匹配任意数字，因而它为数字的一个集合。`{4}`确切地要求它前面的字符（任意数字）出现4次，所以`[[:digit:]]{4}`匹配连在一起的任意4位数字。

需要注意的是，在使用正则表达式时，编写某个特殊的表达式几乎总是有不止一种方法。

```mysql
SELECT prod_name FROM products WHERE prod_name REGEXP '[0-9][0-9][0-9][0-9]' ORDER BY prod_name;
```

#### 定位符

目前为止的所有例子都是匹配一个串中任意位置的文本。为了匹配特定位置的文本，需要使用定位符。

| 元字符 | 说明 |
| :--: | :--: |
|  `^`   | 文本的开始 |
|  `$`   | 文本的结尾 |
| `[[:<:]]` | 词的开始 |
| `[[:>:]]` | 词的结尾 |

