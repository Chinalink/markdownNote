# 算法概述

## 1.1 算法和数据结构

### 什么是算法

算法，对应的英文单词是`algorithm`，最早来自数学领域。在数学领域里，算法是用来解决某一类问题的公式和思想。在计算机科学领域的算法，本质上是一系列程序指令，用于解决特定的运算和逻辑问题。

#### 算法有简单的，也有复杂的

简单的算法如找出一组整数中的最大的数。复杂的算法如在多种物品里选择装入背包的物品，使背包里的物品总价值最大，或找出从一个城市到另一个城市的最短路线。

#### 算法有高效的，也有拙劣的

在计算机领域，衡量算法好坏的重要标准有两个。

- 时间复杂度
- 空间复杂度

#### 算法的应用领域多种多样

1. 运算	2. 查找	3. 排序	4. 最优决策 5. 面试

### 什么是数据结构

数据结构，对应的英文单词是`data structure`，是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。**数据结构是算法的基石**。

#### 线性结构

线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表。

#### 树

树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构。

#### 图

图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系。

#### 其他数据结构

由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等。

## 1.2 时间复杂度

### 基本操作执行次数

`场景1`给小灰1个长度为10cm的面包，小灰每3分钟吃掉1cm，那么吃掉整个面包需要多久？

答案是3 * 10 即30分钟。

如果面包的长度是n cm呢？

此时吃掉整个面包，需要3乘以n即3n分钟。

如果用一个函数来表达吃掉整个面包所需要的时间，可以记作`T(n) = 3n`，n为面包的长度。



设`T(n)`为程序基本操作执行次数的函数（也可以认为是程序的相对执行时间函数），`n`为输入规模，刚才的4个场景分别对应了程序中最常见的4种执行方式。

`场景1 T(n) = 3n`， 执行次数是**线性**的。

```javascript
function eat1(n) {
  for(let i = 0; i < n.length; i++) {
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('吃1cm面包')
  }
}
```

`场景2 T(n) = 5logn`，执行次数是用**对数**计算的。

```javascript
function eat2(n) {
  for(let i = n; i>1; i /= 2) {
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('吃1半面包')
  }
}
```

`场景3 T(n) = 2`，执行次数是**常量**。

```javascript
function eat3(n) {
  console.log('等待1分钟')
  console.log('吃一个鸡腿')
}
```

`场景4 T(n) = 0.5n² + 0.5n`，执行次数是用**多项式**计算的。

```javascript
function eat4(n) {
  for(let i = 0; i < n.length; i++) {
    for(let j = 0; j < i; j++) {
      console.log('等待1分钟')
    }
    console.log('吃1cm面包')
  }
}
```

### 渐进时间复杂度

有了基本操作执行次数的函数`T(n)`，对于分析和比较代码的运行时间，还是有一定困难的。为了解决时间分析的难题，有了**渐进时间复杂度**的概念。

> 若存在函数`f(n)`，使得当`n`趋近于无穷大时，`T(n)/f(n)`的极限值为不等于零的常数，则称`f(n)`是`T(n)`的同数量级函数。记作`T(n) = O(f(n))`，称为`O(f(n))`，`O`为算法的渐进时间复杂度，简称为时间复杂度。

因为渐进时间复杂度用大写`O`来表示，所以也被称为**大O表示法**。

直白地讲，时间复杂度就是把程序的相对执行时间函数`T(n)`简化为一个数量级，这个数量级可以是`n、n²、n³`等。

推导时间复杂度的几个原则。

- 如果运行时间是常数量级，则用常数1表示。
- 只保留时间函数中的最高阶项。
- 如果最高阶项存在，则省去最高阶项前面的系数。

`场景1 T(n) = 3n`，最高阶项为3n，省去系数3，则转化的时间复杂度为：`T(n) = O(n)`

`场景2 T(n) = 5logn`，最高阶项为5logn，省去系数5，则转化的时间复杂度为：`T(n) = O(logn)`

`场景3 T(n) = 2`，只有常数量级，则转化的时间复杂度为：`T(n) = O(1)`

`场景4 T(n) = 0.5n² + 0.5n`，最高阶项为0.5n²，省去系数0.5，则转化的时间复杂度为：`T(n) = O(n²)`

当n的取值足够大时，不难得出以下结论：

**`O(1) < O(logn) < O(n) <O(n²)`**

### 时间复杂度的巨大差异

举例如下：

算法A的执行次数是`T(n) = 100n`，时间复杂度是`O(n)`

算法B的执行次数是`T(n) = 5n²`，时间复杂度是`O(n²)`

算法A运行在小灰家里的老旧电脑上，算法B运行在某台超级计算机上，超级计算机的运行速度是老旧电脑的100倍。

那么，随着输入规模`n`的增长，两种算法谁运行速度更快呢？

|               | T(n) = 100n * 100 |    T(n) = 5n²     |
| :-----------: | :---------------: | :---------------: |
|     n = 1     |      10 000       |         5         |
|     n = 5     |      50 000       |        125        |
|    n = 10     |      100 000      |        500        |
|    n = 100    |     1 000 000     |      50 000       |
|   n = 1 000   |    10 000 000     |     5 000 000     |
|  n = 10 000   |    100 000 000    |    500 000 000    |
|  n = 100 000  |   1 000 000 000   |  50 000 000 000   |
| n = 1 000 000 |  10 000 000 000   | 5 000 000 000 000 |

从上面的表格可以看出，当n的值很小时，算法A的运行用时要远大于算法B；当n的值在1000左右时，算法A和算法B的运行时间已经比较接近；随着n的值越来越大，甚至达到十万、百万时，算法A的优势开始显现出来，算法B的运行速度则越来越慢，差距越来越明显。

这就是不同时间复杂度带来的差距。

## 1.3 空间复杂度

