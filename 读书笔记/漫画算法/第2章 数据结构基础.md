# 数据结构基础

## 什么是数组

数组对应的英文是`array`，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。

```javascript
const arr = [3,1,2,5,4,9,7,2]
```

数组的另一个特点，是在内存中**顺序存储**，因此可以很好地实现逻辑上的**顺序表**。

### 数组的基本操作

#### 读取元素

对于数组来说，读取元素是最简单的操作。由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以读取到对应的数组元素。

像这种根据下标读取元素的方式叫作**随机读取**。

```javascript
const arr = [3,1,2,5,4,9,7,2]
console.log(arr[3]) // 5
```

#### 更新元素

要把数组中某一个元素的值替换为一个新值，也是非常简单的操作。直接利用数组下标，就可以把新值赋给该元素。

```javascript
const arr = [3,1,2,5,4,9,7,2]
arr[3] = 10
console.log(arr[3]) // 10
```

读取元素和更新元素的时间复杂度都是`O(1)`。

#### 插入元素

补充一个概念，数组的实际元素数量有可能小于数组的长度，例如下面的情形。

```javascript
const arr = new Array(5)
arr[1] = 1
console.log(arr) // [empty, 1, empty × 3]
```

`JavaScript`中插入元素可以利用`Array.push()、Array.unshift()、Array.splice()`等方法在数组的任意位置插入元素。

#### 删除元素

```javascript
const arr = [3,1,2,5,4,9,7,2]
arr.shift()
console.log(arr) // [1, 2, 5, 4, 9, 7, 2]
arr.pop()
console.log(arr) // [1, 2, 5, 4, 9, 7]
```

`JavaScript`中插入元素可以利用`Array.shift()、Array.pop()、Array.splice()`等方法在数组的任意位置插入元素。

插入元素和更新元素的时间复杂度都是`O(n)`。

### 数组的优势和劣势

`优势：`数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。有一种高效查找元素的算法叫做二分查找，就是利用了数组的这个优势。

`劣势：`体现在插入和删除元素方面。由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。

总的来说，数组所适合的是**读操作多、写操作少**的场景。

## 什么是链表

### “正规军”和“地下党”

什么是链表？（单向）

在影视作品中，我们可能都见到过地下工作者的经典话语：“上级的姓名、住址，我知道，下级的姓名、住址，我也知道，但是这都是我们党的秘密，不能告诉你们！”

地下党借助这种单线联络的方式，灵活隐秘地传递着各种重要信息。

在计算机科学领域，有一种数据结构也恰恰具备这样的特征，这种数据结构就是**链表**。

`链表(linked list)`是一种在物理上非连续、非顺序的数据结构、由若干`节点（node）`所组成。

**单向**链表的每一个节点又包含两部分，一部分是存放数据的变量`data`，另一部分是指向下一个节点的指针`next`。

```javascript
function node(data) {
  this.data = data
  this.next = null
}
```

链表的第1个节点被称为头节点，最后1个节点被称为尾节点，尾节点的`next`指向`null`。

与数组按照下标来随机寻找元素不同，对于链表的其中一个节点`A`，我们只能根据节点`A`的`next`指针来找到该节点的下一个节点`B`，再根据节点`B`的`next`指针找到下一个节点`C`...

什么是双向链表？

**双向链表**比单向链表稍微复杂一些，它的每一个节点除了拥有`data`和`next`指针，还拥有指向前置节点的`prev`指针。这样就可以让每个节点都能回溯到它的前置节点。

### 链表的基本操作

#### 查找节点

在查找元素时，链表不像数组那样可以通过下标快速进行定位，只能从头节点开始向后一个一个节点逐一查找。

```javascript
function find(data) {
  let currentNode = this.head
  if(currentNode === null) {
    return null
  }
  if(currentNode.data = data) {
    return currentNode
  }
  while(currentNode.next) {
    currentNode = currentNode.next
    if(currentNode.data = data) {
      return currentNode
    }
  }
  return null
}
```

由于链表中的数据只能按顺序进行访问，所以查找节点最坏的时间复杂度是`O(n)`。

### 更新节点

如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据替换成新数据即可。

#### 插入节点

插入节点可分为三种情况：尾部插入、头部插入、中间插入

- 尾部插入，是最简单的情况，把最后一个节点的`next`指针指向新插入的节点即可。

- 头部插入，1. 把新节点的`next`指针指向原先的头节点。 2. 把新节点变为链表的头节点。
- 中间插入，1. 新节点的`next`指针，指向插入位置的节点。2. 插入位置前置节点的`next`指针，指向新节点。

只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要像数组那样考虑扩容的问题。

#### 删除节点

删除节点同样分为三种情况：尾部删除、头部删除、中间删除

- 尾部删除，是最简单的情况，把倒数第2个节点的`next`指针指向空即可。
- 头部删除，也很简单，把链表的头节点设为原先头节点的`next`指针即可。
- 中间删除，同样很简单，把要删除节点的前置节点的`next`指针，指向要删除元素的下一个节点即可。