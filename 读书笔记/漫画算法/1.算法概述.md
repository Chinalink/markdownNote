# 算法概述

## 1.1 算法和数据结构

### 什么是算法

算法，对应的英文单词是`algorithm`，最早来自数学领域。在数学领域里，算法是用来解决某一类问题的公式和思想。在计算机科学领域的算法，本质上是一系列程序指令，用于解决特定的运算和逻辑问题。

#### 算法有简单的，也有复杂的

简单的算法如找出一组整数中的最大的数。复杂的算法如在多种物品里选择装入背包的物品，使背包里的物品总价值最大，或找出从一个城市到另一个城市的最短路线。

#### 算法有高效的，也有拙劣的

在计算机领域，衡量算法好坏的重要标准有两个。

- 时间复杂度
- 空间复杂度

#### 算法的应用领域多种多样

1. 运算	2. 查找	3. 排序	4. 最优决策 5. 面试

### 什么是数据结构

数据结构，对应的英文单词是`data structure`，是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。**数据结构是算法的基石**。

#### 线性结构

线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表。

#### 树

树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构。

#### 图

图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系。

#### 其他数据结构

由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等。

## 1.2 时间复杂度

### 基本操作执行次数

`场景1`给小灰1个长度为10cm的面包，小灰每3分钟吃掉1cm，那么吃掉整个面包需要多久？

答案是3 * 10 即30分钟。

如果面包的长度是n cm呢？

此时吃掉整个面包，需要3乘以n即3n分钟。

如果用一个函数来表达吃掉整个面包所需要的时间，可以记作`T(n) = 3n`，n为面包的长度。



设`T(n)`为程序基本操作执行次数的函数（也可以认为是程序的相对执行时间函数），`n`为输入规模，刚才的4个场景分别对应了程序中最常见的4种执行方式。

`场景1 T(n) = 3n`， 执行次数是**线性**的。

```javascript
function eat1(n) {
  for(let i = 0; i < n.length; i++) {
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('吃1cm面包')
  }
}
```

`场景2 T(n) = 5logn`，执行次数是用**对数**计算的。

```javascript
function eat2(n) {
  for(let i = n; i>1; i /= 2) {
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('等待1分钟')
    console.log('吃1半面包')
  }
}
```

`场景3 T(n) = 2`，执行次数是**常量**。

```javascript
function eat3(n) {
  console.log('等待1分钟')
  console.log('吃一个鸡腿')
}
```

`场景4 T(n) = 0.5n² + 0.5n`，执行次数是用**多项式**计算的。

```javascript
function eat4(n) {
  for(let i = 0; i < n.length; i++) {
    for(let j = 0; j < i; j++) {
      console.log('等待1分钟')
    }
    console.log('吃1cm面包')
  }
}
```

### 渐进时间复杂度

有了基本操作执行次数的函数`T(n)`，对于分析和比较代码的运行时间，还是有一定困难的。为了解决时间分析的难题，有了**渐进时间复杂度**的概念。

> 若存在函数`f(n)`，使得当`n`趋近于无穷大时，`T(n)/f(n)`的极限值为不等于零的常数，则称`f(n)`是`T(n)`的同数量级函数。记作`T(n) = O(f(n))`，称为`O(f(n))`，`O`为算法的渐进时间复杂度，简称为时间复杂度。

因为渐进时间复杂度用大写`O`来表示，所以也被称为**大O表示法**。

直白地讲，时间复杂度就是把程序的相对执行时间函数`T(n)`简化为一个数量级，这个数量级可以是`n、n²、n³`等。

推导时间复杂度的几个原则。

- 如果运行时间是常数量级，则用常数1表示。
- 只保留时间函数中的最高阶项。
- 如果最高阶项存在，则省去最高阶项前面的系数。

`场景1 T(n) = 3n`，最高阶项为3n，省去系数3，则转化的时间复杂度为：`T(n) = O(n)`

`场景2 T(n) = 5logn`，最高阶项为5logn，省去系数5，则转化的时间复杂度为：`T(n) = O(logn)`

`场景3 T(n) = 2`，只有常数量级，则转化的时间复杂度为：`T(n) = O(1)`

`场景4 T(n) = 0.5n² + 0.5n`，最高阶项为0.5n²，省去系数0.5，则转化的时间复杂度为：`T(n) = O(n²)`

当n的取值足够大时，不难得出以下结论：

**`O(1) < O(logn) < O(n) <O(n²)`**

### 时间复杂度的巨大差异

举例如下：

算法A的执行次数是`T(n) = 100n`，时间复杂度是`O(n)`

算法B的执行次数是`T(n) = 5n²`，时间复杂度是`O(n²)`

算法A运行在小灰家里的老旧电脑上，算法B运行在某台超级计算机上，超级计算机的运行速度是老旧电脑的100倍。

那么，随着输入规模`n`的增长，两种算法谁运行速度更快呢？

|               | T(n) = 100n * 100 |    T(n) = 5n²     |
| :-----------: | :---------------: | :---------------: |
|     n = 1     |      10 000       |         5         |
|     n = 5     |      50 000       |        125        |
|    n = 10     |      100 000      |        500        |
|    n = 100    |     1 000 000     |      50 000       |
|   n = 1 000   |    10 000 000     |     5 000 000     |
|  n = 10 000   |    100 000 000    |    500 000 000    |
|  n = 100 000  |   1 000 000 000   |  50 000 000 000   |
| n = 1 000 000 |  10 000 000 000   | 5 000 000 000 000 |

从上面的表格可以看出，当n的值很小时，算法A的运行用时要远大于算法B；当n的值在1000左右时，算法A和算法B的运行时间已经比较接近；随着n的值越来越大，甚至达到十万、百万时，算法A的优势开始显现出来，算法B的运行速度则越来越慢，差距越来越明显。

这就是不同时间复杂度带来的差距。

## 1.3 空间复杂度

简单来说，空间复杂的是执行算法的空间成本。在运行一段程序时，我们不仅要执行各种运算命令，同时也会根据需要，存储一些临时的**中间数据**，以便后续指令可以更方便地继续执行。

在什么情况下需要这些中间数据呢？

`场景1`给出n个整数，其中有两个整数是重复的，要求找出这两个重复的整数。

```javascript
const arr = [3,1,2,5,4,9,7,2]
```



对于这个需求，有很多思路来解决，其中最朴素的方法就是双重循环，根据前面所学方法可以得出，双重循环算法的时间复杂度是`O(n²)`。

```javascript
function fn(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i+1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        return arr[j]
      }
    }
  }
}
```

那么，怎样才能提高算法的效率呢？我们可以利用一些**中间数据**来完成。

```javascript
function fn(arr) {
  let obj = {}
  for (let i = 0; i < arr.length; i++) {
    if (obj[arr[i]]) {
      return arr[i]
    } else {
      obj[arr[i]] = 1
    }
  }
}
```

当遍历整个数列时，每遍历一个整数，就把该整数存储起来，就像放到字典中一样。当遍历下一个整数时，不必再慢慢向前回溯比较，而直接去“字典”中查找，看看有没有对应的整数即可。

由于读写“字典”本身的时间复杂度是`O(1)`，所以整个算法的时间复杂度是`O(n)`，和最初的双重循环相比，运行效率大大提高了。

而这个所谓的“字典”，是一种特殊的数据结构，叫做`散列表`。这个数据结构需要开辟一定的内存空间来存储有用的数据信息。但是，内存空间是有限的，在时间复杂度相同的情况下，算法占用的内存空间自然是越小越好。

如何描述一个算法占用的内存空间大小呢？这就用到了算法的另一个重要指标——`空间复杂度`。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用了大O表示法。

程序占用空间大小的计算公式记作`S(n) = O(f(n))`，其中`n`为问题的规模，`f(n)`为算法所占存储空间的函数。

### 空间复杂度的计算

常见的空间复杂度有下面几种情形。

#### 1. 常量空间

当算法的存储空间大小固定，和输入规模没有直接的关系，空间复杂度记作`O(1)`。

```javascript
function fun1(n) {
  var a = 3
}
```

#### 2. 线性空间

当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模`n`成正比时，空间复杂度记作`O(n)`

```javascript
function fun2(arr) {
}
```

#### 3. 二维空间

当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模`n`成正比时，空间复杂度记作`O(n²)`

```javascript

```

#### 4. 递归空间

递归是一个比较特殊的场景。虽然递归代码并么有显示地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”。

“方法调用栈”包括**进栈**和**出栈**两个行为。

当进入一个新方法时，执行入栈操作，把调用的方法和信息和参数信息压入栈中。

当方法返回时，执行出栈操作，把调用的方法和参数信息从栈中弹出。

```javascript
function fun4(n) {
  if(n <= 1) {
    return
  }
  fun4(n - 1)
}
```

执行递归操作所需要的内存空间和递归的深度成正比。纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是`n`，那么空间复杂度就是`O(n)`

#### 时间与空间的取舍

在绝大多数时候，时间复杂度更为重要一些，我们宁可多分配一些内存空间，也要提升程序的执行速度。

### 1.4 小结

- 什么是算法

在计算机领域里，算法是一系列程序指令，用于处理特定的运算和逻辑问题。

衡量算法优劣的主要标准是时间复杂度和空间复杂度。

- 什么是数据结构

数据结构是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。

数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。

- 什么是时间复杂度

时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作`T(n) = O(f(n))`。

常见的时间复杂度按照从低到高的顺序，包括`O(1)、O(logn)、O(n)、O(nlogn)、O(n²)`等。

- 什么是空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示，记作`S(n) = O(f(n))`。
常见的空间复杂度按照从低到高的顺序，包括`O(1)、O(n)、O(n²)`等。其中递归算法的空间复杂度和递归的深度成正比。

  