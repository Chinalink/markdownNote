# 数据结构基础

## 什么是数组

数组对应的英文是`array`，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。

```javascript
const arr = [3,1,2,5,4,9,7,2]
```

数组的另一个特点，是在内存中**顺序存储**，因此可以很好地实现逻辑上的**顺序表**。

### 数组的基本操作

#### 读取元素

对于数组来说，读取元素是最简单的操作。由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以读取到对应的数组元素。

像这种根据下标读取元素的方式叫作**随机读取**。

```javascript
const arr = [3,1,2,5,4,9,7,2]
console.log(arr[3]) // 5
```

#### 更新元素

要把数组中某一个元素的值替换为一个新值，也是非常简单的操作。直接利用数组下标，就可以把新值赋给该元素。

```javascript
const arr = [3,1,2,5,4,9,7,2]
arr[3] = 10
console.log(arr[3]) // 10
```

读取元素和更新元素的时间复杂度都是`O(1)`。

#### 插入元素

补充一个概念，数组的实际元素数量有可能小于数组的长度，例如下面的情形。

```javascript
const arr = new Array(5)
arr[1] = 1
console.log(arr) // [empty, 1, empty × 3]
```

`JavaScript`中插入元素可以利用`Array.push()、Array.unshift()、Array.splice()`等方法在数组的任意位置插入元素。

#### 删除元素

```javascript
const arr = [3,1,2,5,4,9,7,2]
arr.shift()
console.log(arr) // [1, 2, 5, 4, 9, 7, 2]
arr.pop()
console.log(arr) // [1, 2, 5, 4, 9, 7]
```

`JavaScript`中插入元素可以利用`Array.shift()、Array.pop()、Array.splice()`等方法在数组的任意位置插入元素。

插入元素和更新元素的时间复杂度都是`O(n)`。

### 数组的优势和劣势

`优势：`数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。有一种高效查找元素的算法叫做二分查找，就是利用了数组的这个优势。

`劣势：`体现在插入和删除元素方面。由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。

总的来说，数组所适合的是**读操作多、写操作少**的场景。

## 什么是链表

### “正规军”和“地下党”

什么是链表？（单向）

在影视作品中，我们可能都见到过地下工作者的经典话语：“上级的姓名、住址，我知道，下级的姓名、住址，我也知道，但是这都是我们党的秘密，不能告诉你们！”

地下党借助这种单线联络的方式，灵活隐秘地传递着各种重要信息。

在计算机科学领域，有一种数据结构也恰恰具备这样的特征，这种数据结构就是**链表**。

`链表(linked list)`是一种在物理上非连续、非顺序的数据结构、由若干`节点（node）`所组成。

**单向**链表的每一个节点又包含两部分，一部分是存放数据的变量`data`，另一部分是指向下一个节点的指针`next`。

```javascript
function node(data) {
  this.data = data
  this.next = null
}
```

链表的第1个节点被称为头节点，最后1个节点被称为尾节点，尾节点的`next`指向`null`。

与数组按照下标来随机寻找元素不同，对于链表的其中一个节点`A`，我们只能根据节点`A`的`next`指针来找到该节点的下一个节点`B`，再根据节点`B`的`next`指针找到下一个节点`C`...

什么是双向链表？

**双向链表**比单向链表稍微复杂一些，它的每一个节点除了拥有`data`和`next`指针，还拥有指向前置节点的`prev`指针。这样就可以让每个节点都能回溯到它的前置节点。

### 链表的基本操作

#### 查找节点

在查找元素时，链表不像数组那样可以通过下标快速进行定位，只能从头节点开始向后一个一个节点逐一查找。

```javascript
function find(data) {
  let currentNode = this.head
  if(currentNode === null) {
    return null
  }
  if(currentNode.data = data) {
    return currentNode
  }
  while(currentNode.next) {
    currentNode = currentNode.next
    if(currentNode.data = data) {
      return currentNode
    }
  }
  return null
}
```

由于链表中的数据只能按顺序进行访问，所以查找节点最坏的时间复杂度是`O(n)`。

### 更新节点

如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据替换成新数据即可。

#### 插入节点

插入节点可分为三种情况：尾部插入、头部插入、中间插入

- 尾部插入，是最简单的情况，把最后一个节点的`next`指针指向新插入的节点即可。

- 头部插入，1. 把新节点的`next`指针指向原先的头节点。 2. 把新节点变为链表的头节点。
- 中间插入，1. 新节点的`next`指针，指向插入位置的节点。2. 插入位置前置节点的`next`指针，指向新节点。

只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要像数组那样考虑扩容的问题。

#### 删除节点

删除节点同样分为三种情况：尾部删除、头部删除、中间删除

- 尾部删除，是最简单的情况，把倒数第2个节点的`next`指针指向空即可。
- 头部删除，也很简单，把链表的头节点设为原先头节点的`next`指针即可。
- 中间删除，同样很简单，把要删除节点的前置节点的`next`指针，指向要删除元素的下一个节点即可。

如果不考虑插入、删除操作之前查找元素的过程，只考虑纯粹的插入和删除操作，时间复杂度都是`O(1)`。

### 数组VS链表

|      | 查找 | 更新 | 插入 | 删除 |
| :--: | :--: | :--: | :--: | :--: |
| 数组 | O(1) | O(1) | O(n) | O(n) |
|      | O(n) | O(1) | O(1) | O(1) |

> 从表格可以看出，数组的优势在于能够快速定位元素，对于读操作多、写操作少的场景来说，用数组更合适一些。
>
> 相反地，链表的优势在于能够灵活地进行插入和删除操作，如果需要在尾部频繁插入、删除元素，用链表更合适一些。

## 栈和队列

常用的数据结构有很多，但大多数都以数组或链表作为存储方式。数组和链表可以被看作是数据存储的“物理结构”。

### 物理结构和逻辑结构

什么是数据存储的物理结构？

如果把数据结构比作活生生的人，那么物理结构就是人的血肉和骨骼，看得见，摸得着，实实在在。例如我们刚刚学过的数组和链表，都是内存中实实在在的存储结构。

如果把物质层面的人体比作数据存储的物理结构，那么精神层面的人格则是数据存储的**逻辑结构**。逻辑结构是抽象的概念，它依赖于物理结构而存在。

|          |        线性结构        |  非线性结构  |
| :------: | :--------------------: | :----------: |
| 逻辑结构 | 举例：顺序表、栈、队列 | 举例：树、图 |

|          | 顺序存储结构 | 链式存储结构 |
| :------: | :----------: | :----------: |
| 物理结构 |  举例：数组  |  举例：链表  |

### 什么是栈

`场景`假如有一个又细又长的圆筒，圆筒的一端封闭，另一端开口。往圆筒里放入乒乓球，先放入的靠近圆筒底部，后放入的靠近圆筒入口。那么，要想取出这些乒乓球，则只能按照和放入顺序相反的顺序来取，先取出后放入的，再取出先放入的，而不可能把最里面最先放入的乒乓球优先取出。

`栈(stack)`是一种线性数据结构，栈中的元素只能**`先入后出(First In Last Out，简称FILO)`**。最早进入的元素存放的位置叫作`栈底(bottom)`，最后进入的元素存放的位置叫作`栈顶(top)`。

> 栈这种数据结构既可以用数组来实现，也可以用链表来实现。

### 栈的基本操作

#### 入栈

入栈操作(push)就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。

#### 出栈

出栈操作就是把元素从栈中弹窗，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。

> 入栈和出栈只会影响到最后一个元素，不涉及其他元素的整体移动，所以无论是以数组还是以链表实现，入栈、出栈的时间复杂度都是`O(1)`

### 什么是队列

`场景`假如公路上有一条单行隧道，所有通过隧道的车辆只允许从隧道入口驶入，从隧道出口驶出，不允许逆行。因此，要想让车辆驶出隧道，只能按照它们驶入隧道的顺序，先驶入的车辆先驶出，后驶入的车辆后驶出，任何车辆都无法跳过它前面的车辆提前驶出。

`队列(queue)`是一种线性数据结构，不同于栈的先入后出，队列中的元素只能**`先入先出(First In First Out，简称FIFO)`**。队列的出口端叫作`队头(front)`，队列的入口端叫作`队尾(rear)`。

和栈操作相对应，队列的最基本操作是入队和出队。

### 队列的基本操作

对于链表实现方式，队列的入队、出队操作和栈是大同小异。但对于数组实现方式来说，队列的入队和出队操作有了一些有趣的变化。

#### 入队

入队(enqueue)就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。

#### 出队

出队操作(dequeue)就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。

如果不断出队，队头左边的空间失去作用，队列的容量就会越来越小。用数组实现的队列可以采用**循环队列**的方式来维持队列容量的恒定。
