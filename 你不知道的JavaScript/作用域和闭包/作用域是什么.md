# 作用域是什么



## LHS和RHS

当变量出现在赋值操作的左侧时进行LHS查询。出现在右侧时进行RHS查询。RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。

```javascript
// 其中对a的引用是一个RHS引用，因为这里的a并没有赋予任何值。
console.log(a)
// 这里对a的引用是一个LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为=2这个赋值操作找到一个目标。
a = 2
```

> 赋值操作并不一定意味着就是“=”赋值操作符的左侧或右侧。
>
> 理解为：“赋值操作的目标是谁（LHS）” 以及“谁是赋值操作的源头（RHS）”

```javascript
// 给参数a（隐式地）分配值，需要进行一次LHS查询。
// 同时对a进行RHS引用，将得到的值传给console.log（）
function foo(a) {
  // 对console对象进行RHS查询
  console.log(a) // 2
}
// RHS引用
foo(2)
```

小测验

```javascript
// 参数a 隐式赋值 LHS查询
function foo(a){
  // var b LHS 查询  = a RHS查询
  var b = a
  // a，b RHS查询
  return a + b
}
// var c LHS 查询  foo(2) RHS查询
var c = foo(2)
```

## 作用域嵌套

作用域是根据名称查找变量的一套规则。当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。



```javascript
function foo(a) {
  // 对b进行的RHS引用无法在函数foo内部完成，但可以在上一级作用域中完成
  console.log(a + b)
}
var b = 2
foo(2) // 4
```

> 遍历嵌套作用域的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

## 异常

在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，LHS和RHS查询的行为是不一样的。

```javascript
function foo(a) {
  // 第一次对于b进行RHS查询时是无法找到该变量的。
  console.log(a + b)
  b = a
}
foo(2)
```

> 如果RHS查询在所有嵌套作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。
>
> 当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，**全局作用域**中就会创建一个具有该名称的变量，并将其返回给引擎，前提是程序运行在非“严格模式”

严格模式下，禁止自动或隐式地创建全局变量。严格模式中LHS查询失败时，引擎会抛出同RHS查询失败时类似的ReferenceError异常。接下来，如果RHS查询找到了一个变量，但是如果对这个变量的值进行不合理的操作，引擎会抛出另外一种类型的异常，叫作TypeError。

>ReferenceError同作用域判别失败相关，TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 小结

作用域是一套规则，用于确定在何处以及如何查找变量。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。赋值操作符会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。